// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MessageToClient.proto

#undef min
#undef max

#ifndef GOOGLE_PROTOBUF_INCLUDED_MessageToClient_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MessageToClient_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MessageToClient_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MessageToClient_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MessageToClient_2eproto;
namespace Protobuf {
class GameObject;
class GameObjectDefaultTypeInternal;
extern GameObjectDefaultTypeInternal _GameObject_default_instance_;
class MessageToClient;
class MessageToClientDefaultTypeInternal;
extern MessageToClientDefaultTypeInternal _MessageToClient_default_instance_;
class MessageToClient_GameObjectListEntry_DoNotUse;
class MessageToClient_GameObjectListEntry_DoNotUseDefaultTypeInternal;
extern MessageToClient_GameObjectListEntry_DoNotUseDefaultTypeInternal _MessageToClient_GameObjectListEntry_DoNotUse_default_instance_;
class MessageToClient_ScoresEntry_DoNotUse;
class MessageToClient_ScoresEntry_DoNotUseDefaultTypeInternal;
extern MessageToClient_ScoresEntry_DoNotUseDefaultTypeInternal _MessageToClient_ScoresEntry_DoNotUse_default_instance_;
}  // namespace Protobuf
PROTOBUF_NAMESPACE_OPEN
template<> ::Protobuf::GameObject* Arena::CreateMaybeMessage<::Protobuf::GameObject>(Arena*);
template<> ::Protobuf::MessageToClient* Arena::CreateMaybeMessage<::Protobuf::MessageToClient>(Arena*);
template<> ::Protobuf::MessageToClient_GameObjectListEntry_DoNotUse* Arena::CreateMaybeMessage<::Protobuf::MessageToClient_GameObjectListEntry_DoNotUse>(Arena*);
template<> ::Protobuf::MessageToClient_ScoresEntry_DoNotUse* Arena::CreateMaybeMessage<::Protobuf::MessageToClient_ScoresEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protobuf {

enum ObjType : int {
  People = 0,
  Block = 1,
  Dish = 2,
  Tool = 3,
  Trigger = 4,
  ObjTypeSize = 5,
  ObjType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ObjType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ObjType_IsValid(int value);
constexpr ObjType ObjType_MIN = People;
constexpr ObjType ObjType_MAX = ObjTypeSize;
constexpr int ObjType_ARRAYSIZE = ObjType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjType_descriptor();
template<typename T>
inline const std::string& ObjType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObjType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObjType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObjType_descriptor(), enum_t_value);
}
inline bool ObjType_Parse(
    const std::string& name, ObjType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObjType>(
    ObjType_descriptor(), name, value);
}
enum BlockType : int {
  Wall = 0,
  Table = 1,
  FoodPoint = 2,
  Cooker = 3,
  RubbishBin = 4,
  TaskPoint = 5,
  BlockTypeSize = 6,
  BlockType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BlockType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BlockType_IsValid(int value);
constexpr BlockType BlockType_MIN = Wall;
constexpr BlockType BlockType_MAX = BlockTypeSize;
constexpr int BlockType_ARRAYSIZE = BlockType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BlockType_descriptor();
template<typename T>
inline const std::string& BlockType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BlockType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BlockType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BlockType_descriptor(), enum_t_value);
}
inline bool BlockType_Parse(
    const std::string& name, BlockType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BlockType>(
    BlockType_descriptor(), name, value);
}
enum DishType : int {
  DishEmpty = 0,
  Wheat = 1,
  Rice = 2,
  Tomato = 3,
  Egg = 4,
  Beef = 5,
  Pork = 6,
  Potato = 7,
  Lettuce = 8,
  DishSize1 = 9,
  Flour = 10,
  Noodle = 11,
  Bread = 12,
  Ketchup = 13,
  CookedRice = 14,
  TomatoFriedEgg = 15,
  TomatoFriedEggNoodle = 16,
  BeefNoodle = 17,
  OverRice = 18,
  Barbecue = 19,
  FrenchFries = 20,
  Hamburger = 21,
  SpicedPot = 22,
  SpicedPot3 = 23,
  SpicedPot4 = 24,
  SpicedPot5 = 25,
  SpicedPot6 = 26,
  DishSize2 = 27,
  OverCookedDish = 28,
  DarkDish = 29,
  CookingDish = 30,
  DishSize3 = 31,
  DishType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DishType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DishType_IsValid(int value);
constexpr DishType DishType_MIN = DishEmpty;
constexpr DishType DishType_MAX = DishSize3;
constexpr int DishType_ARRAYSIZE = DishType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DishType_descriptor();
template<typename T>
inline const std::string& DishType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DishType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DishType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DishType_descriptor(), enum_t_value);
}
inline bool DishType_Parse(
    const std::string& name, DishType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DishType>(
    DishType_descriptor(), name, value);
}
enum ToolType : int {
  ToolEmpty = 0,
  TigerShoes = 1,
  SpeedBuff = 2,
  StrengthBuff = 3,
  TeleScope = 4,
  Condiment = 5,
  Fertilizer = 6,
  BreastPlate = 7,
  SpaceGate = 8,
  WaveGlueBottle = 9,
  LandMine = 10,
  TrapTool = 11,
  FlashBomb = 12,
  ThrowHammer = 13,
  Bow = 14,
  Stealer = 15,
  ToolSize = 16,
  ToolType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ToolType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ToolType_IsValid(int value);
constexpr ToolType ToolType_MIN = ToolEmpty;
constexpr ToolType ToolType_MAX = ToolSize;
constexpr int ToolType_ARRAYSIZE = ToolType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ToolType_descriptor();
template<typename T>
inline const std::string& ToolType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ToolType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ToolType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ToolType_descriptor(), enum_t_value);
}
inline bool ToolType_Parse(
    const std::string& name, ToolType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ToolType>(
    ToolType_descriptor(), name, value);
}
enum TriggerType : int {
  WaveGlue = 0,
  Trap = 1,
  Mine = 2,
  Bomb = 3,
  Arrow = 4,
  Hammer = 5,
  TriggerSize = 6,
  TriggerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TriggerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TriggerType_IsValid(int value);
constexpr TriggerType TriggerType_MIN = WaveGlue;
constexpr TriggerType TriggerType_MAX = TriggerSize;
constexpr int TriggerType_ARRAYSIZE = TriggerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TriggerType_descriptor();
template<typename T>
inline const std::string& TriggerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TriggerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TriggerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TriggerType_descriptor(), enum_t_value);
}
inline bool TriggerType_Parse(
    const std::string& name, TriggerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TriggerType>(
    TriggerType_descriptor(), name, value);
}
enum Direction : int {
  Right = 0,
  RightUp = 1,
  Up = 2,
  LeftUp = 3,
  Left = 4,
  LeftDown = 5,
  Down = 6,
  RightDown = 7,
  DirectionSize = 8,
  Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Direction_IsValid(int value);
constexpr Direction Direction_MIN = Right;
constexpr Direction Direction_MAX = DirectionSize;
constexpr int Direction_ARRAYSIZE = Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Direction_descriptor();
template<typename T>
inline const std::string& Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Direction_descriptor(), enum_t_value);
}
inline bool Direction_Parse(
    const std::string& name, Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Direction>(
    Direction_descriptor(), name, value);
}
enum Talent : int {
  None = 0,
  Runner = 1,
  StrongMan = 2,
  Cook = 3,
  Technician = 4,
  LuckyBoy = 5,
  TalentSize = 6,
  Talent_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Talent_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Talent_IsValid(int value);
constexpr Talent Talent_MIN = None;
constexpr Talent Talent_MAX = TalentSize;
constexpr int Talent_ARRAYSIZE = Talent_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Talent_descriptor();
template<typename T>
inline const std::string& Talent_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Talent>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Talent_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Talent_descriptor(), enum_t_value);
}
inline bool Talent_Parse(
    const std::string& name, Talent* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Talent>(
    Talent_descriptor(), name, value);
}
// ===================================================================

class GameObject :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protobuf.GameObject) */ {
 public:
  GameObject();
  virtual ~GameObject();

  GameObject(const GameObject& from);
  GameObject(GameObject&& from) noexcept
    : GameObject() {
    *this = ::std::move(from);
  }

  inline GameObject& operator=(const GameObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameObject& operator=(GameObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameObject* internal_default_instance() {
    return reinterpret_cast<const GameObject*>(
               &_GameObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(GameObject* other);
  friend void swap(GameObject& a, GameObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameObject* New() const final {
    return CreateMaybeMessage<GameObject>(nullptr);
  }

  GameObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameObject>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameObject& from);
  void MergeFrom(const GameObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameObject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protobuf.GameObject";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MessageToClient_2eproto);
    return ::descriptor_table_MessageToClient_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string RecieveText = 10;
  void clear_recievetext();
  static const int kRecieveTextFieldNumber = 10;
  const std::string& recievetext() const;
  void set_recievetext(const std::string& value);
  void set_recievetext(std::string&& value);
  void set_recievetext(const char* value);
  void set_recievetext(const char* value, size_t size);
  std::string* mutable_recievetext();
  std::string* release_recievetext();
  void set_allocated_recievetext(std::string* recievetext);

  // double PositionX = 1;
  void clear_positionx();
  static const int kPositionXFieldNumber = 1;
  double positionx() const;
  void set_positionx(double value);

  // double PositionY = 2;
  void clear_positiony();
  static const int kPositionYFieldNumber = 2;
  double positiony() const;
  void set_positiony(double value);

  // .Protobuf.Direction Direction = 3;
  void clear_direction();
  static const int kDirectionFieldNumber = 3;
  ::Protobuf::Direction direction() const;
  void set_direction(::Protobuf::Direction value);

  // .Protobuf.ObjType ObjType = 4;
  void clear_objtype();
  static const int kObjTypeFieldNumber = 4;
  ::Protobuf::ObjType objtype() const;
  void set_objtype(::Protobuf::ObjType value);

  // .Protobuf.BlockType BlockType = 5;
  void clear_blocktype();
  static const int kBlockTypeFieldNumber = 5;
  ::Protobuf::BlockType blocktype() const;
  void set_blocktype(::Protobuf::BlockType value);

  // .Protobuf.DishType DishType = 6;
  void clear_dishtype();
  static const int kDishTypeFieldNumber = 6;
  ::Protobuf::DishType dishtype() const;
  void set_dishtype(::Protobuf::DishType value);

  // .Protobuf.ToolType ToolType = 7;
  void clear_tooltype();
  static const int kToolTypeFieldNumber = 7;
  ::Protobuf::ToolType tooltype() const;
  void set_tooltype(::Protobuf::ToolType value);

  // .Protobuf.TriggerType TriggerType = 8;
  void clear_triggertype();
  static const int kTriggerTypeFieldNumber = 8;
  ::Protobuf::TriggerType triggertype() const;
  void set_triggertype(::Protobuf::TriggerType value);

  // bool isMoving = 9;
  void clear_ismoving();
  static const int kIsMovingFieldNumber = 9;
  bool ismoving() const;
  void set_ismoving(bool value);

  // int32 team = 11;
  void clear_team();
  static const int kTeamFieldNumber = 11;
  ::PROTOBUF_NAMESPACE_ID::int32 team() const;
  void set_team(::PROTOBUF_NAMESPACE_ID::int32 value);

  // double MoveSpeed = 13;
  void clear_movespeed();
  static const int kMoveSpeedFieldNumber = 13;
  double movespeed() const;
  void set_movespeed(double value);

  // int32 SightRange = 12;
  void clear_sightrange();
  static const int kSightRangeFieldNumber = 12;
  ::PROTOBUF_NAMESPACE_ID::int32 sightrange() const;
  void set_sightrange(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 MaxThrowDistance = 14;
  void clear_maxthrowdistance();
  static const int kMaxThrowDistanceFieldNumber = 14;
  ::PROTOBUF_NAMESPACE_ID::int32 maxthrowdistance() const;
  void set_maxthrowdistance(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Protobuf.GameObject)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recievetext_;
  double positionx_;
  double positiony_;
  int direction_;
  int objtype_;
  int blocktype_;
  int dishtype_;
  int tooltype_;
  int triggertype_;
  bool ismoving_;
  ::PROTOBUF_NAMESPACE_ID::int32 team_;
  double movespeed_;
  ::PROTOBUF_NAMESPACE_ID::int32 sightrange_;
  ::PROTOBUF_NAMESPACE_ID::int32 maxthrowdistance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MessageToClient_2eproto;
};
// -------------------------------------------------------------------

class MessageToClient_GameObjectListEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MessageToClient_GameObjectListEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, ::Protobuf::GameObject,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MessageToClient_GameObjectListEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, ::Protobuf::GameObject,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  MessageToClient_GameObjectListEntry_DoNotUse();
  MessageToClient_GameObjectListEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MessageToClient_GameObjectListEntry_DoNotUse& other);
  static const MessageToClient_GameObjectListEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MessageToClient_GameObjectListEntry_DoNotUse*>(&_MessageToClient_GameObjectListEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MessageToClient_2eproto);
    return ::descriptor_table_MessageToClient_2eproto.file_level_metadata[1];
  }

  public:
};

// -------------------------------------------------------------------

class MessageToClient_ScoresEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MessageToClient_ScoresEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MessageToClient_ScoresEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    0 > SuperType;
  MessageToClient_ScoresEntry_DoNotUse();
  MessageToClient_ScoresEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MessageToClient_ScoresEntry_DoNotUse& other);
  static const MessageToClient_ScoresEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MessageToClient_ScoresEntry_DoNotUse*>(&_MessageToClient_ScoresEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MessageToClient_2eproto);
    return ::descriptor_table_MessageToClient_2eproto.file_level_metadata[2];
  }

  public:
};

// -------------------------------------------------------------------

class MessageToClient :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protobuf.MessageToClient) */ {
 public:
  MessageToClient();
  virtual ~MessageToClient();

  MessageToClient(const MessageToClient& from);
  MessageToClient(MessageToClient&& from) noexcept
    : MessageToClient() {
    *this = ::std::move(from);
  }

  inline MessageToClient& operator=(const MessageToClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageToClient& operator=(MessageToClient&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessageToClient& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageToClient* internal_default_instance() {
    return reinterpret_cast<const MessageToClient*>(
               &_MessageToClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MessageToClient* other);
  friend void swap(MessageToClient& a, MessageToClient& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageToClient* New() const final {
    return CreateMaybeMessage<MessageToClient>(nullptr);
  }

  MessageToClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageToClient>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessageToClient& from);
  void MergeFrom(const MessageToClient& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageToClient* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protobuf.MessageToClient";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MessageToClient_2eproto);
    return ::descriptor_table_MessageToClient_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int64, .Protobuf.GameObject> GameObjectList = 1;
  int gameobjectlist_size() const;
  void clear_gameobjectlist();
  static const int kGameObjectListFieldNumber = 1;
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::Protobuf::GameObject >&
      gameobjectlist() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::Protobuf::GameObject >*
      mutable_gameobjectlist();

  // repeated .Protobuf.DishType Tasks = 2;
  int tasks_size() const;
  void clear_tasks();
  static const int kTasksFieldNumber = 2;
  ::Protobuf::DishType tasks(int index) const;
  void set_tasks(int index, ::Protobuf::DishType value);
  void add_tasks(::Protobuf::DishType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& tasks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_tasks();

  // map<int32, int32> Scores = 3;
  int scores_size() const;
  void clear_scores();
  static const int kScoresFieldNumber = 3;
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >&
      scores() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_scores();

  // @@protoc_insertion_point(class_scope:Protobuf.MessageToClient)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MessageToClient_GameObjectListEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int64, ::Protobuf::GameObject,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > gameobjectlist_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> tasks_;
  mutable std::atomic<int> _tasks_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MessageToClient_ScoresEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      0 > scores_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MessageToClient_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GameObject

// double PositionX = 1;
inline void GameObject::clear_positionx() {
  positionx_ = 0;
}
inline double GameObject::positionx() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.PositionX)
  return positionx_;
}
inline void GameObject::set_positionx(double value) {
  
  positionx_ = value;
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.PositionX)
}

// double PositionY = 2;
inline void GameObject::clear_positiony() {
  positiony_ = 0;
}
inline double GameObject::positiony() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.PositionY)
  return positiony_;
}
inline void GameObject::set_positiony(double value) {
  
  positiony_ = value;
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.PositionY)
}

// .Protobuf.Direction Direction = 3;
inline void GameObject::clear_direction() {
  direction_ = 0;
}
inline ::Protobuf::Direction GameObject::direction() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.Direction)
  return static_cast< ::Protobuf::Direction >(direction_);
}
inline void GameObject::set_direction(::Protobuf::Direction value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.Direction)
}

// .Protobuf.ObjType ObjType = 4;
inline void GameObject::clear_objtype() {
  objtype_ = 0;
}
inline ::Protobuf::ObjType GameObject::objtype() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.ObjType)
  return static_cast< ::Protobuf::ObjType >(objtype_);
}
inline void GameObject::set_objtype(::Protobuf::ObjType value) {
  
  objtype_ = value;
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.ObjType)
}

// .Protobuf.BlockType BlockType = 5;
inline void GameObject::clear_blocktype() {
  blocktype_ = 0;
}
inline ::Protobuf::BlockType GameObject::blocktype() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.BlockType)
  return static_cast< ::Protobuf::BlockType >(blocktype_);
}
inline void GameObject::set_blocktype(::Protobuf::BlockType value) {
  
  blocktype_ = value;
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.BlockType)
}

// .Protobuf.DishType DishType = 6;
inline void GameObject::clear_dishtype() {
  dishtype_ = 0;
}
inline ::Protobuf::DishType GameObject::dishtype() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.DishType)
  return static_cast< ::Protobuf::DishType >(dishtype_);
}
inline void GameObject::set_dishtype(::Protobuf::DishType value) {
  
  dishtype_ = value;
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.DishType)
}

// .Protobuf.ToolType ToolType = 7;
inline void GameObject::clear_tooltype() {
  tooltype_ = 0;
}
inline ::Protobuf::ToolType GameObject::tooltype() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.ToolType)
  return static_cast< ::Protobuf::ToolType >(tooltype_);
}
inline void GameObject::set_tooltype(::Protobuf::ToolType value) {
  
  tooltype_ = value;
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.ToolType)
}

// .Protobuf.TriggerType TriggerType = 8;
inline void GameObject::clear_triggertype() {
  triggertype_ = 0;
}
inline ::Protobuf::TriggerType GameObject::triggertype() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.TriggerType)
  return static_cast< ::Protobuf::TriggerType >(triggertype_);
}
inline void GameObject::set_triggertype(::Protobuf::TriggerType value) {
  
  triggertype_ = value;
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.TriggerType)
}

// bool isMoving = 9;
inline void GameObject::clear_ismoving() {
  ismoving_ = false;
}
inline bool GameObject::ismoving() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.isMoving)
  return ismoving_;
}
inline void GameObject::set_ismoving(bool value) {
  
  ismoving_ = value;
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.isMoving)
}

// string RecieveText = 10;
inline void GameObject::clear_recievetext() {
  recievetext_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameObject::recievetext() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.RecieveText)
  return recievetext_.GetNoArena();
}
inline void GameObject::set_recievetext(const std::string& value) {
  
  recievetext_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.RecieveText)
}
inline void GameObject::set_recievetext(std::string&& value) {
  
  recievetext_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Protobuf.GameObject.RecieveText)
}
inline void GameObject::set_recievetext(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  recievetext_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Protobuf.GameObject.RecieveText)
}
inline void GameObject::set_recievetext(const char* value, size_t size) {
  
  recievetext_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Protobuf.GameObject.RecieveText)
}
inline std::string* GameObject::mutable_recievetext() {
  
  // @@protoc_insertion_point(field_mutable:Protobuf.GameObject.RecieveText)
  return recievetext_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameObject::release_recievetext() {
  // @@protoc_insertion_point(field_release:Protobuf.GameObject.RecieveText)
  
  return recievetext_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameObject::set_allocated_recievetext(std::string* recievetext) {
  if (recievetext != nullptr) {
    
  } else {
    
  }
  recievetext_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), recievetext);
  // @@protoc_insertion_point(field_set_allocated:Protobuf.GameObject.RecieveText)
}

// int32 team = 11;
inline void GameObject::clear_team() {
  team_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameObject::team() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.team)
  return team_;
}
inline void GameObject::set_team(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  team_ = value;
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.team)
}

// int32 SightRange = 12;
inline void GameObject::clear_sightrange() {
  sightrange_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameObject::sightrange() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.SightRange)
  return sightrange_;
}
inline void GameObject::set_sightrange(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sightrange_ = value;
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.SightRange)
}

// double MoveSpeed = 13;
inline void GameObject::clear_movespeed() {
  movespeed_ = 0;
}
inline double GameObject::movespeed() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.MoveSpeed)
  return movespeed_;
}
inline void GameObject::set_movespeed(double value) {
  
  movespeed_ = value;
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.MoveSpeed)
}

// int32 MaxThrowDistance = 14;
inline void GameObject::clear_maxthrowdistance() {
  maxthrowdistance_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameObject::maxthrowdistance() const {
  // @@protoc_insertion_point(field_get:Protobuf.GameObject.MaxThrowDistance)
  return maxthrowdistance_;
}
inline void GameObject::set_maxthrowdistance(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  maxthrowdistance_ = value;
  // @@protoc_insertion_point(field_set:Protobuf.GameObject.MaxThrowDistance)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MessageToClient

// map<int64, .Protobuf.GameObject> GameObjectList = 1;
inline int MessageToClient::gameobjectlist_size() const {
  return gameobjectlist_.size();
}
inline void MessageToClient::clear_gameobjectlist() {
  gameobjectlist_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::Protobuf::GameObject >&
MessageToClient::gameobjectlist() const {
  // @@protoc_insertion_point(field_map:Protobuf.MessageToClient.GameObjectList)
  return gameobjectlist_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::Protobuf::GameObject >*
MessageToClient::mutable_gameobjectlist() {
  // @@protoc_insertion_point(field_mutable_map:Protobuf.MessageToClient.GameObjectList)
  return gameobjectlist_.MutableMap();
}

// repeated .Protobuf.DishType Tasks = 2;
inline int MessageToClient::tasks_size() const {
  return tasks_.size();
}
inline void MessageToClient::clear_tasks() {
  tasks_.Clear();
}
inline ::Protobuf::DishType MessageToClient::tasks(int index) const {
  // @@protoc_insertion_point(field_get:Protobuf.MessageToClient.Tasks)
  return static_cast< ::Protobuf::DishType >(tasks_.Get(index));
}
inline void MessageToClient::set_tasks(int index, ::Protobuf::DishType value) {
  tasks_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protobuf.MessageToClient.Tasks)
}
inline void MessageToClient::add_tasks(::Protobuf::DishType value) {
  tasks_.Add(value);
  // @@protoc_insertion_point(field_add:Protobuf.MessageToClient.Tasks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
MessageToClient::tasks() const {
  // @@protoc_insertion_point(field_list:Protobuf.MessageToClient.Tasks)
  return tasks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MessageToClient::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:Protobuf.MessageToClient.Tasks)
  return &tasks_;
}

// map<int32, int32> Scores = 3;
inline int MessageToClient::scores_size() const {
  return scores_.size();
}
inline void MessageToClient::clear_scores() {
  scores_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >&
MessageToClient::scores() const {
  // @@protoc_insertion_point(field_map:Protobuf.MessageToClient.Scores)
  return scores_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::int32 >*
MessageToClient::mutable_scores() {
  // @@protoc_insertion_point(field_mutable_map:Protobuf.MessageToClient.Scores)
  return scores_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protobuf

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Protobuf::ObjType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::ObjType>() {
  return ::Protobuf::ObjType_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::BlockType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::BlockType>() {
  return ::Protobuf::BlockType_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::DishType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::DishType>() {
  return ::Protobuf::DishType_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::ToolType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::ToolType>() {
  return ::Protobuf::ToolType_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::TriggerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::TriggerType>() {
  return ::Protobuf::TriggerType_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::Direction>() {
  return ::Protobuf::Direction_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::Talent> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::Talent>() {
  return ::Protobuf::Talent_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MessageToClient_2eproto
